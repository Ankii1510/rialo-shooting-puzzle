import React, { useEffect, useRef, useState } from "react";

const RIALO_URL = "https://www.rialo.io/";
const DEFAULT_PROXY = "https://r.jina.ai/http://";

const STATIC_QUESTIONS = [
  { q: "What can you do on Rialo?", correct: "Earn", wrong: ["Cook", "Chat"] },
  { q: "Rialo is primarily focused on?", correct: "On-chain finance", wrong: ["Social media", "Streaming"] },
  { q: "Which feature commonly appears in DeFi platforms?", correct: "Liquidity", wrong: ["Baking", "Messaging"] },
  { q: "Which action helps you grow funds?", correct: "Stake", wrong: ["Swipe", "Post"] },
  { q: "A common DeFi component is?", correct: "Yield", wrong: ["Stories", "Profiles"] },
];

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function randBetween(a,b){ return a + Math.random()*(b-a); }

export default function RialoShootingPuzzle({ corsProxy = DEFAULT_PROXY }) {
  const [fragments, setFragments] = useState([]);
  const [questions, setQuestions] = useState([]);
  const [loading, setLoading] = useState(true);
  const [score, setScore] = useState(0);
  const [lives, setLives] = useState(3);
  const [roundIndex, setRoundIndex] = useState(0);
  const [targets, setTargets] = useState([]);
  const [message, setMessage] = useState('Fetching questions‚Ä¶');
  const [soundOn, setSoundOn] = useState(true);
  const containerRef = useRef(null);
  const nextId = useRef(1);
  const animRef = useRef(null);
  const audioCtxRef = useRef(null);

  // audio
  useEffect(()=>{
    return ()=>{ try{ audioCtxRef.current && audioCtxRef.current.close(); }catch(e){} }
  },[]);

  function playBeep(freq=440, type='sine', time=0.06){
    if(!soundOn) return;
    try{
      if(!audioCtxRef.current) audioCtxRef.current = new (window.AudioContext||window.webkitAudioContext)();
      const ctx = audioCtxRef.current;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type=type; o.frequency.value=freq;
      g.gain.value=0.0001;
      o.connect(g); g.connect(ctx.destination);
      const now = ctx.currentTime;
      g.gain.exponentialRampToValueAtTime(0.12, now+0.01);
      o.start(now);
      g.gain.exponentialRampToValueAtTime(0.0001, now+time);
      o.stop(now+time+0.02);
    }catch(e){console.warn('Audio failed',e)}
  }
  function playHit(){ playBeep(880,'square',0.08); }
  function playMiss(){ playBeep(220,'sawtooth',0.12); }

  // fetch questions
  useEffect(()=>{
    let mounted=true;
    async function fetchFragments(){
      setLoading(true);
      try{
        const res = await fetch((corsProxy||"")+RIALO_URL);
        if(!res.ok) throw new Error('fetch failed');
        const text = await res.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(text,'text/html');
        const tags=['h1','h2','h3','a','p','li'];
        const snippets=[];
        tags.forEach(t=>{
          doc.querySelectorAll(t).forEach(el=>{
            const s=el.textContent.trim();
            if(s && s.length>2 && s.length<40) snippets.push(s);
          });
        });
        const unique=Array.from(new Set(snippets)).slice(0,30);
        if(unique.length>=5 && mounted){ setFragments(unique); setMessage('Live questions loaded'); }
        else { setFragments([]); setMessage('Using static questions'); }
      }catch(err){ console.warn(err); setFragments([]); setMessage('Fetch failed ‚Äî using static questions'); }
      finally{ if(mounted) setLoading(false); }
    }
    fetchFragments();
    return ()=>{ mounted=false; }
  },[corsProxy]);

  // build questions
  useEffect(()=>{
    const dyn=[];
    const pool=fragments.slice();
    while(dyn.length<5 && pool.length){
      const a=pool.splice(Math.floor(Math.random()*pool.length),1)[0];
      const short=a.split('\n')[0].split(' - ')[0].split(':')[0].trim();
      if(short.length>2 && short.length<32){
        dyn.push({ q:`Which option relates to: "${short}"?`, correct:short, wrong:generateWrongOptions(short) });
      }
    }
    setQuestions([...STATIC_QUESTIONS.slice(0,5), ...dyn].slice(0,10));
  },[fragments]);

  function generateWrongOptions(correct){
    const candidates = ['Swap','Earn','Borrow','Stake','Liquidity','Yield','NFT','Governance','Bridge','Token','Marketplace','Bond'];
    const out=[];
    while(out.length<2){
      const c=candidates[Math.floor(Math.random()*candidates.length)];
      if(c!==correct && !out.includes(c)) out.push(c);
    }
    return out;
  }

  // spawn targets
  useEffect(()=>{
    setTargets([]);
    if(questions.length===0) return;
    spawnTargets(roundIndex);
  },[roundIndex, questions]);

  function spawnTargets(index){
    const q=questions[index]; if(!q) return;
    const container = containerRef.current; 
    const rect = container ? container.getBoundingClientRect() : { width: 800, height: 400 };
    const pool=[q.correct,...q.wrong];
    for(let i=pool.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [pool[i],pool[j]]=[pool[j],pool[i]]; }

    const tcount=clamp(6+index,6,12);
    const newTargets=[];
    for(let i=0;i<tcount;i++){
      const id=nextId.current++;
      const frag=pool[i%pool.length];
      const size=randBetween(70,120);
      const fromLeft=Math.random()<0.5;
      const speed=randBetween(0.4,1.4)*clamp(1+index*0.08,0.8,2);
      newTargets.push({id, x:fromLeft?-150:rect.width+150, y:randBetween(40,rect.height-100), vx:fromLeft?speed:-speed, frag, size, hit:false});
    }
    setTargets(newTargets);
  }

  // animation
  useEffect(()=>{
    function tick(){
      setTargets(prev=>{
        const container = containerRef.current;
        const rect = container ? container.getBoundingClientRect() : { width:800, height:400 };
        return prev.map(t=>({...t, x:t.x+t.vx})).filter(t=> t.x>-300 && t.x<rect.width+300 && !t.remove);
      });
      animRef.current=requestAnimationFrame(tick);
    }
    animRef.current=requestAnimationFrame(tick);
    return ()=>cancelAnimationFrame(animRef.current);
  },[]);

  function shoot(id){
    const t=targets.find(tt=>tt.id===id); if(!t) return;
    const currentQ=questions[roundIndex]; if(!currentQ) return;
    setTargets(prev=>prev.map(x=>x.id===id?{...x,hit:true}:x));
    if(t.frag===currentQ.correct){
      setScore(s=>s+10);
      playHit();
      setMessage('‚úÖ Correct!');
      setTimeout(()=>{
        if(roundIndex+1>=questions.length) setMessage('üéâ You finished all questions!');
        else setRoundIndex(r=>r+1);
      },500);
    }else{
      setLives(l=>l-1);
      playMiss();
      setMessage('‚ùå Wrong!');
      if(lives-1<=0) setTimeout(()=> setMessage('üíÄ Game Over!'),200);
    }
    setTimeout(()=>{ setTargets(prev=>prev.filter(x=>x.id!==id)); },350);
  }

  function resetGame(){
    setScore(0); setLives(3); setRoundIndex(0); set


